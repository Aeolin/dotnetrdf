using System.Diagnostics.CodeAnalysis;
using VDS.RDF.Query.Algebra;

namespace VDS.RDF.Query.Pull
{
    /**
     * Represents the context for evaluation of a SPARQL expression
     */
    public class ExpressionContext(ISet bindings, IRefNode? activeGraph)
    {
        /**
         * Get the set of variable bindings that apply to the expression evaluation.
         */
        public readonly ISet Bindings = bindings;
        /**
         * Get the name of the active graph to use for the expression evaluation.
         */
        public readonly IRefNode? ActiveGraph = activeGraph;
        
        /**
         * A map of the blank nodes generated during expression evaluation,
         * mapping the blank node identifier specified in the query to the node generated during evaluation.
         */
        private Dictionary<string, IBlankNode>? _blankNodeMap = null;

        /**
         * Attempt to retrieve the blank node that was previously generated for the specified blank node identifier.
         * Returns true if such a mapping exists, false otherwise.
         * <param name="key">The blank node identifier specified in the SPARQL expression</param>
         * <param name="bNode">Receives the blank node instance generated by the expression evaluation. Guaranteed to be non-null if the return value is true.</param>
         */
        public bool TryGetBlankNode(string key, [NotNullWhen(returnValue:true)]out IBlankNode? bNode)
        {
            bNode = null;
            return _blankNodeMap?.TryGetValue(key, out bNode) ?? false;
        }

        /**
         * Record the blank node instance generated for the specified blank node identifier when evaluating the expression.
         */
        public void MapBlankNode(string key, IBlankNode bNode)
        {
            _blankNodeMap ??= new Dictionary<string, IBlankNode>();
            _blankNodeMap.Add(key, bNode);
        }
    }
}