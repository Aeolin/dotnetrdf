/*******************************************************************************
 * Copyright (c) 2009 TopQuadrant, Inc.
 * All rights reserved. 
 *******************************************************************************/
using VDS.RDF.Storage;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System;
using VDS.RDF.Query.Spin.Model;
using org.topbraid.spin.util;
using System.Text;
using VDS.RDF.Query.Spin.SparqlUtil;
using VDS.RDF;
using VDS.RDF.Query.Spin;
using VDS.RDF.Query.Spin.Model.visitor;
using VDS.RDF.Query;
using VDS.RDF.Query.Spin.Util;
using VDS.RDF.Parsing;
using VDS.RDF.Update;
using VDS.RDF.Query.Spin.Model;
using VDS.RDF.Query.Spin.LibraryOntology;
using VDS.RDF.Query.Datasets;

namespace org.topbraid.spin.arq
{
    /**
     * A singleton that can create ARQ SPARQL Queries and QueryExecution
     * objects.  SPIN API users should use the provided methods here.
     * 
     * @author Holger Knublauch
     */
    public class ARQFactory
    {

        private static ARQFactory singleton = new ARQFactory();

        /**
         * Caches parsable query strings for each SPIN Command or expression INode.
         */
        private ConcurrentDictionary<INode, String> node2String = new ConcurrentDictionary<INode, String>();

        /**
         * Caches Jena query objects for each SPIN Command or expression String.
         */
        private ConcurrentDictionary<String, SparqlParameterizedString> string2Query = new ConcurrentDictionary<String, SparqlParameterizedString>();

        /**
         * Caches Jena query objects for each SPIN Command or expression String.
         */
        private ConcurrentDictionary<String, SparqlParameterizedString> string2Update = new ConcurrentDictionary<String, SparqlParameterizedString>();

        private bool useCaches = true;


        /**
         * Gets the singleton instance of this class.
         * @return the singleton
         */
        public static ARQFactory get()
        {
            return singleton;
        }


        /**
         * Changes the singleton to some subclass.
         * @param value  the new ARQFactory (not null)
         */
        public static void set(ARQFactory value)
        {
            ARQFactory.singleton = value;
        }


        /**
         * Can be overloaded to install extra things such as Lucene indices to all
         * local QueryExecutions generated by this factory.
         * Does nothing by default.
         * @param qexec  the QueryExecution to modify
         */
        protected void adjustQueryExecution(SparqlParameterizedString qexec)
        {
        }


        /**
         * Programmatically resets any cached queries.
         */
        public void clearCaches()
        {
            node2String.Clear();
            string2Query.Clear();
            string2Update.Clear();
        }


        /**
         * Converts a given SPIN Command (Query or Update) into a parsable String.
         * This method is the recommended way of doing this task as it uses a cache
         * to prevent duplicate computations.
         * @param spinCommand  the SPIN Command to convert to String
         * @return the String
         */
        public String createCommandString(ICommand spinCommand)
        {
            if (!node2String.ContainsKey(spinCommand))
            {
                String result =String.Empty;
                String text = spinCommand.getString(SP.PropertyText);
                if (text != null)
                {
                    //result = ARQFactory.get().createPrefixDeclarations(spinCommand.getModel()) + text;
                }
                else
                {
                    //StringSparqlPrinter p = new StringSparqlPrinter();
                    //p.setUsePrefixes(false);
                    //p.setPrintPrefixes(false);
                    //spinCommand.print(p);
                    //result = p.getString();
                }
                if (useCaches)
                {
                    node2String[spinCommand] = result;
                }
                return result;
            }
            else
            {
                return node2String[spinCommand];
            }
        }


        public String createExpressionString(IResource expression)
        {
            if (!node2String.ContainsKey(expression))
            {
                //StringSparqlPrinter p = new StringSparqlPrinter();
                //p.setUsePrefixes(false);
                //SPINExpressions.printExpressionString(p, expression, false, false, expression.getModel().getNsPrefixMap());
                String result = String.Empty; // p.getString();
                if (useCaches)
                {
                    node2String[expression] = result;
                }
                return result;
            }
            else
            {
                return node2String[expression];
            }
        }


        public SparqlParameterizedString createExpressionQuery(IResource expression)
        {
            String queryString = createExpressionString(expression);
            return createExpressionQuery(queryString);
        }


        public SparqlParameterizedString createExpressionQuery(String expression)
        {
            if (!string2Query.ContainsKey(expression))
            {
                
                String queryString = "SELECT (" + expression + ") WHERE {}";
                SparqlParameterizedString result = doCreateQuery(queryString);
                if (useCaches)
                {
                    string2Query[expression] = result;
                }
                return result;
            }
            else { 
                return string2Query[expression];
            }
        }


        /**
         * Same as <code>createPrefixDeclarations(model, true)</code>.
         * @param model  the IUpdateableStorage to create prefix declarations for
         * @return the prefix declarations
         */
        public String createPrefixDeclarations(SpinWrappedDataset model)
        {
            return createPrefixDeclarations(model, true);
        }


        /**
         * Creates SPARQL prefix declarations for a given IUpdateableStorage.
         * @param model  the IUpdateableStorage to get the prefixes from
         * @param includeExtraPrefixes  true to also include implicit prefixes like afn
         * @return the prefix declarations
         */
        public String createPrefixDeclarations(SpinWrappedDataset model, bool includeExtraPrefixes)
        {
            StringBuilder queryString = new StringBuilder();
            String defaultNamespace = null; //TODO JenaUtil.getNsPrefixURI(model, "");
            if (defaultNamespace != null)
            {
                queryString.Append("PREFIX :   <" + defaultNamespace + ">\n");
            }
            if (includeExtraPrefixes)
            {
                INamespaceMapper extraPrefixes = new NamespaceMapper(); // ExtraPrefixes.getExtraPrefixes();
                foreach (String prefix in extraPrefixes.Prefixes)
                {
                    Uri ns = extraPrefixes.GetNamespaceUri(prefix);
                    perhapsAppend(queryString, prefix, ns, model);
                }
            }
            IEnumerator<String> prefixes = new Dictionary<String, String>().Keys.GetEnumerator(); // model.getNsPrefixMap().Keys.GetEnumerator();
            while (prefixes.MoveNext())
            {
                String prefix = prefixes.Current;
                String ns = null; // JenaUtil.getNsPrefixURI(model, prefix);
                if (prefix.Length > 0 && ns != null)
                {
                    queryString.Append("PREFIX " + prefix + ": <" + ns + ">\n");
                }
            }
            return queryString.ToString();
        }


        /**
         * Converts a SPIN Query object into a ARQ Query.
         * This method is the recommended way for this conversion -
         * it uses a cache to retrieve queries that it has already seen before.
         * @param spinQuery  the SPIN query
         * @return the ARQ Query
         */
        public SparqlParameterizedString createQuery(IQuery spinQuery)
        {
            String queryString = createCommandString(spinQuery);
            return createQuery(queryString);
        }


        public SparqlParameterizedString createQuery(String queryString)
        {
            SparqlParameterizedString result = null;
            if (string2Query.ContainsKey(queryString))
            {
                result = string2Query[queryString];
            }
            if (result == null)
            {
                result = doCreateQuery(queryString);
                if (useCaches)
                {
                    string2Query[queryString] = result;
                }
            }
            return result;
        }


        public SparqlParameterizedString doCreateQuery(String queryString)
        {
            return doCreateQuery(queryString, null);
        }


        /**
         * Creates the "physical" Jena Query instance.
         * Can be overloaded to create engine-specific Query objects such as those
         * for AllegroGraph.
         * @param queryString  the parsable query string
         * @param prefixMapping  an optional PrefixMapping to initialize the Query with
         *                       (this object may be modified)
         * @return the ARQ Query object
         */
        protected SparqlParameterizedString doCreateQuery(String queryString, INamespaceMapper prefixMapping)
        {
            SparqlParameterizedString query = new SparqlParameterizedString();
            if (prefixMapping != null)
            {
                query.Namespaces.Import(prefixMapping);
            }
            query.CommandText = queryString;
            return query;
        }


        /**
         * Creates a new Query from a partial query (possibly lacking
         * PREFIX declarations), using the ARQ syntax specified by <code>getSyntax</code>.
         * @param model  the IUpdateableStorage to operate on
         * @param partialQuery  the (partial) query string
         * @return the Query
         */
        public SparqlParameterizedString createQuery(SpinWrappedDataset queryModel, String partialQuery)
        {
            INamespaceMapper pm = new NamespaceMapper(); // new PrefixMappingImpl();
            Uri defaultNamespace = null; // JenaUtil.getNsPrefixURI(model, "");
            if (defaultNamespace != null)
            {
                pm.AddNamespace("", defaultNamespace);
            }
            INamespaceMapper extraPrefixes = new NamespaceMapper(); // ExtraPrefixes.getExtraPrefixes();
            foreach (String prefix in extraPrefixes.Prefixes)
            {
                Uri ns = extraPrefixes.GetNamespaceUri(prefix);
                if (ns != null && pm.GetNamespaceUri(prefix) == null)
                {
                    pm.AddNamespace(prefix, ns);
                }
            }
            foreach (String prefix in queryModel.Namespaces.Prefixes)
            {
                Uri ns = queryModel.Namespaces.GetNamespaceUri(prefix);
                if (prefix.Length > 0 && ns != null)
                {
                    pm.AddNamespace(prefix, ns);
                }
            }
            return doCreateQuery(partialQuery, pm);
        }


        /**
         * Creates a QueryExecution for a given Query in a given IUpdateableStorage,
         * with no initial bindings.
         * The implementation basically uses Jena's QueryExecutionFactory
         * but with the option to use different Dataset as specified by
         * <code>getDataset(model)</code>.
         * @param query  the Query
         * @param model  the IUpdateableStorage to query
         * @return a QueryExecution
         */
        public SparqlQuery createQueryExecution(IQuery query, SpinWrappedDataset model)
        {
            return createQueryExecution(query, model, null);
        }


        /**
         * Creates a QueryExecution for a given Query in a given IUpdateableStorage, with
         * some given initial bindings.
         * The implementation basically uses Jena's QueryExecutionFactory
         * but with the option to use different Dataset as specified by
         * <code>getDataset(model)</code>.
         * @param query  the Query
         * @param model  the IUpdateableStorage to query
         * @param initialBinding  the initial variable bindings or null
         * @return a QueryExecution
         */
        public SparqlQuery createQueryExecution(IQuery query, SpinWrappedDataset model, Dictionary<String, INode> initialBinding)
        {
            IEnumerable<Uri> dataset = getDataset(model);
            return createQueryExecution(query, dataset, initialBinding);
        }


        public SparqlQuery createQueryExecution(IQuery query, IEnumerable<Uri> dataset)
        {
            return createQueryExecution(query, dataset, null);
        }


        public SparqlQuery createQueryExecution(IQuery query, IEnumerable<Uri> dataset, Dictionary<String, INode> initialBinding)
        {
            /*
            if (!query.getGraphURIs().isEmpty() || !query.getNamedGraphURIs().isEmpty())
            {
                dataset = new FromDataset(dataset, query);
            }
            */
            SparqlParameterizedString queryString = new SparqlParameterizedString(); // DatasetUtil.createQuery(query, dataset, initialBinding);
            SparqlQuery qexec = new SparqlQueryParser().ParseFromString(queryString);
            //adjustQueryExecution(qexec);
            return qexec;
        }


        ///**
        // * Creates a remote QueryExecution on a given Query.
        // * @param query  the Query to execute
        // * @return a remote QueryExecution
        // */
        //public QueryEngineHTTP createRemoteQueryExecution(Query query)
        //{
        //    List<String> graphURIs = query.getGraphURIs();
        //    return createRemoteQueryExecution(query, graphURIs);
        //}


        //public QueryEngineHTTP createRemoteQueryExecution(Query query, List<String> graphURIs)
        //{
        //    String service = graphURIs.get(0);
        //    String serviceAsURI = service;
        //    if (service.endsWith("/sparql"))
        //    {
        //        serviceAsURI = service.substring(0, service.lastIndexOf('/'));
        //    }
        //    return createRemoteQueryExecution(service, query, Collections.singletonList(serviceAsURI), graphURIs, null, null);
        //}


        //public QueryEngineHTTP createRemoteQueryExecution(
        //        String service,
        //        Query query,
        //        List<String> defaultGraphURIs,
        //        List<String> namedGraphURIs,
        //        String user,
        //        char[] password)
        //{
        //    QueryEngineHTTP qexec = (QueryEngineHTTP)QueryExecutionFactory.sparqlService(service, query);
        //    if (defaultGraphURIs.size() > 0)
        //    {
        //        qexec.setDefaultGraphURIs(defaultGraphURIs);
        //    }
        //    if (namedGraphURIs.size() > 0)
        //    {
        //        qexec.setNamedGraphURIs(namedGraphURIs);
        //    }
        //    if (user != null)
        //    {
        //        qexec.setBasicAuthentication(user, password);
        //    }
        //    return qexec;
        //}


        public SparqlParameterizedString createUpdateRequest(String parsableString)
        {
            SparqlParameterizedString result = null;
            if (string2Update.ContainsKey(parsableString))
            {
                result = string2Update[parsableString];
            }
            if (result == null)
            {
                result = new SparqlParameterizedString(parsableString);
                if (useCaches)
                {
                    string2Update[parsableString] = result;
                }
            }
            return result;
        }


        public SparqlParameterizedString createUpdateRequest(IUpdate spinUpdate)
        {
            String s = createCommandString(spinUpdate);
            return createUpdateRequest(s);
        }


        /**
         * Specifies a Dataset that shall be used for query execution.
         * Returns a new DatasetImpl by default but may be overloaded in subclasses.
         * For example, TopBraid delegates this to the currently open Graphs.
         * @param defaultModel  the default IUpdateableStorage of the Dataset
         * @return the Dataset or null
         */
        public IEnumerable<Uri> getDataset(SpinWrappedDataset defaultModel)
        {
            return new List<Uri>();// defaultModel.ListGraphs();
        }


        /**
         * Gets a list of named graphs (GRAPH elements) mentioned in a given
         * Query.
         * @param query  the Query to traverse
         * @return a List of those GRAPHs
         */
        public static List<Uri> getNamedGraphURIs(IQuery query)
        {
            /*sealed*/
            List<Uri> results = new List<Uri>();
            //ElementWalker.visit(query.getQueryPattern(), new ElementVisitorBase());// {
            //    override 		public void visit(ElementNamedGraph el) {
            //        INode node = el.getGraphNameNode();
            //        if(node != null && node.isURI()) {
            //            String uri = node.Uri;
            //            if(!results.Contains(uri)) {
            //                results.Add(uri);
            //            }
            //        }
            //    }
            //});
            return results;
        }


        /**
         * The ARQ Syntax used by default: Syntax.syntaxARQ.
         * @return the default syntax
         */
        //public Syntax getSyntax()
        //{
        //    return Syntax.syntaxARQ;
        //}


        public bool isUsingCaches()
        {
            return useCaches;
        }


        private static void perhapsAppend(StringBuilder queryString, String prefix, Uri ns, SpinWrappedDataset model)
        {
            if (model.Namespaces.GetNamespaceUri(prefix) == null && ns != null)
            {
                queryString.Append("PREFIX ");
                queryString.Append(prefix);
                queryString.Append(": <");
                queryString.Append(ns);
                queryString.Append(">\n");
            }
        }


        /**
         * Tells the ARQFactory whether to use caches for the various createXY functions.
         * These are on by default.
         * @param value  false to switch caches off
         */
        public void setUseCaches(bool value)
        {
            this.useCaches = value;
        }
    }
}