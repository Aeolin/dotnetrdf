using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using VDS.RDF.Query.Patterns;

namespace VDS.RDF.Query
{
    /// <summary>
    /// Helper Class used in the execution of Sparql Queries
    /// </summary>
    /// <remarks>
    /// <para>
    /// The purpose of the Result Binder is to store intermediate results generated during the query execution process and to match
    /// up bindings of variables into possible solutions
    /// </para>
    /// <para>
    /// At some point I will try and write up a complete explanation of how the Sparql Query execution works but this will take quite a bit
    /// of time which I don't have at the moment.
    /// </para>
    /// </remarks>
    public class SparqlResultBinder : IDisposable
    {
        private const int LargeBindThreshold = 5000;

        #region Instance Variables

        private SparqlQuery _query;
        private Dictionary<String, List<Binding>> _bindings; //REDO: Store as a Dictionary<String, Dictionary<int, Binding>> instead
        private List<BindingSolution> _solutions;
        private Dictionary<int,BindingGroup> _groups = null;
        private List<String> _transactions;
        private int _currPatternID = -1;
        private int _currTriplePatternID = -1;
        private int _maxPatternID = -1;
        private int _maxBindingID = -1;
        private int _maxTriplePatternID = -1;
        private List<int> _validBindingsIDs;
        private List<int> _tempBindingIDs;
        private List<String> _tempVariables;
        private Dictionary<ITriplePattern, int> _triplePatternIDs;
        private bool _disjoint = false;
        private int _patternCount = 0;
        private int _totalPatternCount = 0;
        private long _executionTimeout = 0;
        private Stopwatch _executionTimer = null;

        #endregion

        /// <summary>
        /// Creates a new Results Binder
        /// </summary>
        /// <param name="query">Query this provides Result Binding to</param>
        public SparqlResultBinder(SparqlQuery query)
        {
            this._query = query;
            this._bindings = new Dictionary<String, List<Binding>>();
            this._solutions = new List<BindingSolution>();
            this._transactions = new List<String>();
            this._validBindingsIDs = new List<int>();
            this._tempBindingIDs = new List<int>();
            this._tempVariables = new List<string>();
            this._triplePatternIDs = new Dictionary<ITriplePattern, int>();
        }

        /// <summary>
        /// Creates a new Results Binder deep copied from an existing Results Binder
        /// </summary>
        /// <param name="binder">Results Binder to clone</param>
        protected internal SparqlResultBinder(SparqlResultBinder binder) 
            : this(binder._query)
        {
            //Import the Bindings
            foreach (String var in binder._bindings.Keys)
            {
                this._bindings.Add(var, new List<Binding>());
                foreach (Binding b in binder._bindings[var])
                {
                    this._bindings[var].Add(b);
                }
            }

            //Import Transactions
            foreach (String var in binder._transactions)
            {
                this._transactions.Add(var);
            }

            //Import Valid Binding IDs
            foreach (int id in binder._validBindingsIDs)
            {
                this._validBindingsIDs.Add(id);
            }

            //Import Temporary Binding IDs
            foreach (int id in binder._tempBindingIDs)
            {
                this._tempBindingIDs.Add(id);
            }

            //Import Temporary Variables
            foreach (String var in binder._tempVariables)
            {
                this._tempVariables.Add(var);
            }

            //Import Triple Pattern IDs
            foreach (ITriplePattern p in binder._triplePatternIDs.Keys)
            {
                this._triplePatternIDs.Add(p, binder._triplePatternIDs[p]);
            }

            //Import Execution Timer
            this._executionTimer = binder._executionTimer;

            //Copy Pattern and Binding ID counters
            this._currPatternID = binder._currPatternID;
            this._currTriplePatternID = binder._currTriplePatternID;
            this._maxPatternID = binder._maxPatternID;
            this._maxBindingID = binder._maxBindingID;
            this._maxTriplePatternID = binder._maxTriplePatternID;
            this._disjoint = false;
            this._patternCount = binder._patternCount;
            this._totalPatternCount = binder._totalPatternCount;
            this._executionTimeout = binder._executionTimeout;
        }

        #region Public Properties

        /// <summary>
        /// Gets whether there any Result Bindings
        /// </summary>
        public bool HasBindings
        {
            get
            {
                return (this._validBindingsIDs.Count > 0);
            }
        }

        /// <summary>
        /// Gets whether a given Variable has existing Bindings (i.e. values already bound to it)
        /// </summary>
        /// <param name="name">Variable Name</param>
        /// <returns></returns>
        public bool HasVariableBindings(String name)
        {
            if (name == null)
            {
                return false;
            }
            else
            {
                return (this._bindings.ContainsKey(name) && !this._transactions.Contains(name));
            }
        }

        /// <summary>
        /// Gets whether a given Node is bound to a given Variable
        /// </summary>
        /// <param name="name">Variable Name</param>
        /// <param name="value">Node</param>
        /// <returns></returns>
        public bool IsBound(String name, INode value)
        {
            if (this._bindings.ContainsKey(name))
            {
                return this._bindings[name].Any(b => b.Node.Equals(value));
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the Variables that the Binder stores Bindings for
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (from var in this._bindings.Keys
                        select var);
            }
        }

        /// <summary>
        /// Gets the enumeration of valid Binding IDs
        /// </summary>
        public IEnumerable<int> BindingIDs
        {
            get
            {
                return (from id in this._validBindingsIDs
                        select id);
            }
        }

        /// <summary>
        /// Gets the set of Solutions that result from the Query this Binder provides Binding to
        /// </summary>
        public IEnumerable<BindingSolution> Solutions
        {
            get
            {
                return (from s in this._solutions
                        select s);
            }
        }

        /// <summary>
        /// Gets the set of Groups that result from the Query this Binder provides Binding to
        /// </summary>
        public IEnumerable<BindingGroup> Groups
        {
            get
            {
                if (this._groups != null)
                {
                    return (from g in this._groups.Values
                            select g);
                }
                else
                {
                    return Enumerable.Empty<BindingGroup>();
                }
            }
        }

        /// <summary>
        /// Gets the Value bound to a given Variable for a given Binding ID
        /// </summary>
        /// <param name="name">Variable Name</param>
        /// <param name="bindingID">Binding ID</param>
        /// <returns></returns>
        public INode Value(String name, int bindingID)
        {
            if (this._bindings.ContainsKey(name))
            {
                List<Binding> bs = this._bindings[name];
                Binding temp = bs.Find(b => b.BindingID == bindingID);
                
                return ((temp == null) ? null : temp.Node);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the Group referred to by the given ID
        /// </summary>
        /// <param name="groupID">Group ID</param>
        /// <returns></returns>
        public BindingGroup Group(int groupID) {
            if (this._groups != null)
            {
                if (this._groups.ContainsKey(groupID))
                {
                    return this._groups[groupID];
                }
                else
                {
                    throw new RDFQueryException("The Group with ID " + groupID + " does not exist in the Result Binder");
                }
            }
            else
            {
                throw new RDFQueryException("Cannot lookup a Group when the Query has not been executed or does not contain Groups as part of it's Results");
            }
        }

        /// <summary>
        /// Checks whether the given ID refers to a Group
        /// </summary>
        /// <param name="groupID">Group ID</param>
        /// <returns></returns>
        public bool IsGroup(int groupID)
        {
            if (this._groups == null)
            {
                return false;
            }
            else
            {
                return this._groups.ContainsKey(groupID);
            }
        }

        /// <summary>
        /// Gets/Sets the Execution Timeout in Milliseconds
        /// </summary>
        public long QueryTimeout
        {
            get
            {
                return this._executionTimeout;
            }
            set
            {
                if (value >= 0)
                {
                    this._executionTimeout = value;
                }
                else
                {
                    this._executionTimeout = Options.QueryExecutionTimeout;
                }
            }
        }

        /// <summary>
        /// Gets the amount of Time taken to execute the Query in Milliseconds
        /// </summary>
        public long QueryTime
        {
            get
            {
                if (this._executionTimer != null)
                {
                    return this._executionTimer.ElapsedMilliseconds;
                }
                else
                {
                    return 0;
                }
            }
        }

        /// <summary>
        /// Gets the amount of Time taken to execute the Query in Ticks
        /// </summary>
        public long QueryTimeTicks
        {
            get
            {
                if (this._executionTimer != null)
                {
                    return this._executionTimer.ElapsedTicks;
                }
                else
                {
                    return 0;
                }
            }
        }

        #endregion

        #region Private Properties

        private int VariableCount(int bindingID)
        {
            return this._bindings.Sum((p => p.Value.Count(b => b.BindingID == bindingID)));
        }

        private int GetTriplePatternID(int bindingID)
        {
            foreach (String var in this._bindings.Keys)
            {
                foreach (Binding b in this._bindings[var])
                {
                    if (b.BindingID == bindingID) return b.TriplePatternID;
                }
            }

            return -1;
        }

        private List<int> GetOtherBindings(int triplePatternID)
        {
            return (from bs in this._bindings.Values
                    from b in bs
                    where b.TriplePatternID != triplePatternID && this.VariableCount(b.BindingID) < this._bindings.Keys.Count
                    select b.BindingID).Distinct().ToList();            
        }

        /// <summary>
        /// Creates a new Pattern ID
        /// </summary>
        /// <returns></returns>
        protected internal int CreatePatternID()
        {
            this._maxPatternID++;
            return this._maxPatternID;
        }

        /// <summary>
        /// Gets/Sets the current Pattern ID
        /// </summary>
        protected internal int PatternID
        {
            get
            {
                return this._currPatternID;
            }
            set
            {
                this._currPatternID = value;
            }
        }

        /// <summary>
        /// Gets/Sets the current Triple Pattern ID
        /// </summary>
        protected internal int TriplePatternID
        {
            get
            {
                return this._currTriplePatternID;
            }
            set
            {
                this._currTriplePatternID = value;
            }
        }

        /// <summary>
        /// Gets/Sets the current Max Triple Pattern ID
        /// </summary>
        protected internal int MaxTriplePatternID
        {
            get
            {
                return this._maxTriplePatternID;
            }
            set
            {
                this._maxTriplePatternID = value;
            }
        }

        /// <summary>
        /// Gets the enumeration of Binding IDs that have not yet been committed
        /// </summary>
        protected internal IEnumerable<int> TemporaryBindingIDs
        {
            get
            {
                return (from id in this._tempBindingIDs
                        select id);
            }
        }

        #endregion

        #region Binding Methods

        /// <summary>
        /// Called at the start of Query Execution to prepare the Result Binder
        /// </summary>
        protected internal void StartExecution()
        {
            //Create the Stopwatch 
            this._executionTimer = new Stopwatch();
            this._executionTimer.Start();
        }

        /// <summary>
        /// Called at the end of Query Execution to convert the Bindings into Solutions
        /// </summary>
        protected internal void EndExecution(SparqlQuery query)
        {
            //Generate Groups if applicable
            if (query.GroupBy != null)
            {
                //Apply the Group By to get Groups
                List<BindingGroup> groups = query.GroupBy.Apply(this);
                this._groups = new Dictionary<int, BindingGroup>();

                //Turn each Group into a Binding
                this._maxBindingID++;
                int firstBindingID = this._maxBindingID;
                int nextBindingID = firstBindingID;
                int firstID = 0;
                Binding binding;

                foreach (BindingGroup group in groups)
                {
                    //Add to Groups List
                    this._groups.Add(nextBindingID, group);

                    //Populate the Variable Bindings for the Group
                    firstID = group.BindingIDs.First();
                    foreach (SparqlVariable var in query.Variables)
                    {
                        if (var.IsResultVariable)
                        {
                            if (var.IsAggregate)
                            {
                                INode aggValue = var.Aggregate.Apply(this, group.BindingIDs);
                                binding = new Binding(aggValue, nextBindingID, 0, 0);
                            }
                            else if (var.IsProjection)
                            {
                                INode projValue;
                                try
                                {
                                    projValue = var.Projection.Value(this, firstID);
                                }
                                catch (RDFQueryException)
                                {
                                    projValue = null;
                                }
                                binding = new Binding(projValue, nextBindingID, 0, 0);
                            }
                            else
                            {
                                INode value = this.Value(var.Name, firstID);
                                binding = new Binding(value, nextBindingID, 0, 0);
                            }
                            if (!this._bindings.ContainsKey(var.Name)) this._bindings.Add(var.Name, new List<Binding>());
                            this._bindings[var.Name].Add(binding);
                        }
                    }

                    this._validBindingsIDs.Add(nextBindingID);
                    nextBindingID++;
                }

                //Apply the Having Clause
                //Do this before removing irrelevant Bindings since they may be used in the Having Filter
                if (query.GroupBy.Having != null)
                {
                    query.GroupBy.Having.Apply(this, true);
                }

                //Remove all Bindings not related to Groups
                foreach (String var in this._bindings.Keys)
                {
                    this._bindings[var].RemoveAll(b => b.BindingID < firstBindingID);
                }
                this._validBindingsIDs.RemoveAll(i => i < firstBindingID);

                //Then generate Solutions
                foreach (int i in this._validBindingsIDs)
                {
                    BindingSolution solution = new BindingSolution(query, this, i);
                    this._solutions.Add(solution);
                }
            }
            else
            {
                //Generate the Binding Solutions if the Result is not an Aggregate
                if (!query.IsAggregate)
                {
                    foreach (SparqlVariable var in query.Variables)
                    {
                        if (var.IsProjection && !this._bindings.ContainsKey(var.Name))
                        {
                            this._bindings.Add(var.Name, new List<Binding>());
                        }
                    }
                    foreach (int i in this._validBindingsIDs)
                    {
                        BindingSolution solution = new BindingSolution(query, this, i);
                        this._solutions.Add(solution);
                    }
                }
            }

            //Stop the Stopwatch
            this._executionTimer.Stop();
        }

        /// <summary>
        /// Starts a new Bind Transaction for the given Triple Pattern
        /// </summary>
        /// <param name="pattern">Triple Pattern</param>
        protected internal void StartBindTransaction(ITriplePattern pattern) {
            String name;

            //Create a Triple Pattern ID
            if (!this._triplePatternIDs.ContainsKey(pattern))
            {
                this._maxTriplePatternID++;
                this._triplePatternIDs.Add(pattern, this._maxTriplePatternID);
                this._currTriplePatternID = this._maxTriplePatternID;
            }
            else
            {
                this._currTriplePatternID = this._triplePatternIDs[pattern];
            }

            this._patternCount++;
            this._totalPatternCount++;

            if (pattern is TriplePattern)
            {
                TriplePattern p = (TriplePattern)pattern;

                //Is Subject a Variable/Temporary Variable?
                if (p.Subject.VariableName != null)
                {
                    name = p.Subject.VariableName;
                    if (!this._bindings.ContainsKey(name))
                    {
                        this._transactions.Add(name);
                        this._bindings.Add(name, new List<Binding>());
                        if (!this._tempVariables.Contains(name)) this._tempVariables.Add(name);
                    }
                }

                //Is Predicate a Variable/Temporary Variable?
                if (p.Predicate.VariableName != null)
                {
                    name = p.Predicate.VariableName;
                    if (!this._bindings.ContainsKey(name))
                    {
                        this._transactions.Add(name);
                        this._bindings.Add(name, new List<Binding>());
                        if (!this._tempVariables.Contains(name)) this._tempVariables.Add(name);
                    }
                }

                //Is Object a Variable/Temporary Variable?
                if (p.Object.VariableName != null)
                {
                    name = p.Object.VariableName;
                    if (!this._bindings.ContainsKey(name))
                    {
                        this._transactions.Add(name);
                        this._bindings.Add(name, new List<Binding>());
                        if (!this._tempVariables.Contains(name)) this._tempVariables.Add(name);
                    }
                }
            }
            else if (pattern is LetPattern)
            {
                LetPattern let = (LetPattern)pattern;
                if (!this._bindings.ContainsKey(let.VariableName))
                {
                    this._bindings.Add(let.VariableName, new List<Binding>());
                    if (!this._tempVariables.Contains(let.VariableName)) this._tempVariables.Add(let.VariableName);
                }

                //Never disjoint for a LET, we'll always associated one value with each existing Binding
                this._disjoint = false;
            }
            else if (pattern is SubQueryPattern)
            {
                SubQueryPattern subquery = (SubQueryPattern)pattern;

                //TODO: Check semantics of this
                //May be disjoint if things aren't projected in
                if (subquery.Variables.All(v => !this.HasVariableBindings(v)))
                {
                    this._disjoint = true;
                }
                else
                {
                    this._disjoint = false;
                }

                foreach (String var in subquery.Variables)
                {
                    if (!this._bindings.ContainsKey(var))
                    {
                        this._transactions.Add(var);
                        this._bindings.Add(var, new List<Binding>());
                        if (!this._tempVariables.Contains(var)) this._tempVariables.Add(var);
                    }
                }

               
            }
        }

        /// <summary>
        /// Ends the current Bind Transaction
        /// </summary>
        protected internal void EndBindTransaction() {
            this._transactions.Clear();

            this.CheckTimeout();

            //Check for empty result sets
            if (this._bindings.Keys.All(var => this._bindings[var].Count == 0))
            {
                throw new RDFQueryTerminatedException();
            }

            //Handle Disjoint Patterns by making all possible solution pairings
            if (this._disjoint && this._totalPatternCount > 1)
            {
                List<int> removableBindings = new List<int>();
                List<int> temp = (from i in this._tempBindingIDs select i).ToList();
                foreach (int i in temp)
                {
                    if (this.VariableCount(i) < this._bindings.Keys.Count && !removableBindings.Contains(i))
                    {
                        int pID = this.GetTriplePatternID(i);

                        List<int> otherBindings = this.GetOtherBindings(pID);
                        foreach (int j in otherBindings)
                        {
                            this.PairBindings(i, j);
                            removableBindings.Add(j);
                        }
                        removableBindings.Add(i);
                    }

                    this.CheckTimeout();
                }

                removableBindings = removableBindings.Distinct().ToList();
                foreach (int i in removableBindings)
                {
                    this.Unbind(i);
                    this._tempBindingIDs.Remove(i);
                }
            }
        }

        /// <summary>
        /// Binds values from  Triple based on the given Triple Pattern
        /// </summary>
        /// <param name="t">Triple to bind values from</param>
        /// <param name="pattern">Triple Pattern to bind based upon</param>
        protected internal void Bind(Triple t, TriplePattern pattern)
        {
            //Find the Variables used (if any)
            String s, p, o;
            s = pattern.Subject.VariableName;
            p = pattern.Predicate.VariableName;
            o = pattern.Object.VariableName;

            //Where variables are present - bind the values
            int bindingID = this.GetBindingID(s,p,o);
            if (bindingID != -1)
            {
                if (s != null) this._bindings[s].Add(new Binding(t.Subject, bindingID, this._currTriplePatternID, this._currPatternID));
                if (p != null) this._bindings[p].Add(new Binding(t.Predicate, bindingID, this._currTriplePatternID, this._currPatternID));
                if (o != null) this._bindings[o].Add(new Binding(t.Object, bindingID, this._currTriplePatternID, this._currPatternID));

                this._tempBindingIDs.Add(bindingID);
            }
        }

        /// <summary>
        /// Gets a Binding ID for a new Binding
        /// </summary>
        /// <param name="s">Variable Name for the Subject Variable (if any)</param>
        /// <param name="p">Variable Name for the Predicate Variable (if any)</param>
        /// <param name="o">Variable Name for the Object Variable (if any)</param>
        /// <returns></returns>
        /// <remarks>If there are no Variable Names (all are nulls) in the three parameters a -1 will be returned which indicates that no Binding need take place</remarks>
        protected internal int GetBindingID(String s, String p, String o)
        {
            if (s == null && p == null && o == null)
            {
                //No Binds permitted when there are no variables present
                return -1;
            }
            else
            {
                this._maxBindingID++;
                return this._maxBindingID;
            }
        }

        /// <summary>
        /// Commits binds created during a Graph Pattern execution as Valid Binds
        /// </summary>
        /// <param name="optional">Indicates whether the commit is in the context of an OPTIONAL clause</param>
        protected internal void CommitBinds(bool optional)
        {
            this.CheckTimeout();

            List<int> tempBindingIDs = this._tempBindingIDs.ToList();
            if (tempBindingIDs.Count > LargeBindThreshold)
            {
                int c = 0;
                //Each Temporary Binding must have successfully bound on each variable
                foreach (int id in tempBindingIDs)
                {
                    bool ok = this._tempVariables.All(v => (this.Value(v, id) != null));
                    if (ok)
                    {
                        this._validBindingsIDs.Add(id);
                    }
                    else
                    {
                        this.Unbind(id);
                    }

                    //Check Timeout at regular intervals
                    c++;
                    if (c == LargeBindThreshold)
                    {
                        this.CheckTimeout();
                        c = 0;
                    }
                }
            }
            else
            {
                //Each Temporary Binding must have successfully bound on each variable
                foreach (int id in tempBindingIDs)
                {
                    bool ok = this._tempVariables.All(v => (this.Value(v, id) != null));
                    if (ok)
                    {
                        this._validBindingsIDs.Add(id);
                    }
                    else
                    {
                        this.Unbind(id);
                    }
                }
            }

            //Clean up after commit
            foreach (String var in this._tempVariables)
            {
                //Can get rid of Bindings pertaining to Blank Node Temporary Variables
                if (var.StartsWith("_:"))
                {
                    this._bindings.Remove(var);
                }
            }
            this._tempBindingIDs.Clear();
            if (!optional)
            {
                //Clear Temporary Variable list if not currently in an OPTIONAL clause
                this._tempVariables.Clear();
            }
            //this._disjoint = true;
            this._patternCount = 0;
        }

        /// <summary>
        /// Used to bind the Graph Uri of each result from a GRAPH Clause to the Graph variable
        /// </summary>
        /// <param name="var">Graph variable</param>
        protected internal void BindGraph(String var)
        {
            if (!this._bindings.ContainsKey(var))
            {
                //Bind the Graph URI for each Binding to the Graph Variable
                this._bindings.Add(var, new List<Binding>());
            }

            foreach (int id in this._tempBindingIDs)
            {
                INode temp = (from bs in this._bindings.Values
                              from b in bs
                              where b.BindingID == id && b.Node != null
                              select b.Node).First();

                URINode graphUri = new URINode(null, temp.GraphURI);
                this._bindings[var].Add(new Binding(graphUri, id, 0, this._currPatternID));
            }

        }

        /// <summary>
        /// UNIONs a result from a sub-binder object that has been created to execute a UNION clause into the main Binder results
        /// </summary>
        /// <param name="binder">Sub-binder object</param>
        /// <param name="id">Binding ID</param>
        protected internal void UnionBind(SparqlResultBinder binder, int id)
        {
            this._maxBindingID++;
            foreach (String var in binder.Variables)
            {
                if (!this._bindings.ContainsKey(var))
                {
                    this._bindings.Add(var, new List<Binding>());
                }
                Binding temp = binder._bindings[var].Find(b => b.BindingID == id);
                this._bindings[var].Add(new Binding(temp.Node, this._maxBindingID, this._currTriplePatternID, this._currPatternID));
            }
            this._validBindingsIDs.Add(this._maxBindingID);
        }

        /// <summary>
        /// Commits the results of executing a Graph Pattern
        /// </summary>
        /// <param name="parentOptional">Indicates whether we are currently in the scope of an OPTIONAL clause</param>
        /// <param name="discardBindings">Indicates whether bindings generated for variables introdcued by this Graph Pattern should be discarded</param>
        /// <remarks>
        /// The <paramref name="discardBindings">discardBindings</paramref> parameter is used to indicate that bindings for variables introduced in this Graph Pattern should be discarded, this is needed for EXISTS and NOT EXISTS clauses
        /// </remarks>
        protected internal void Commit(bool parentOptional, bool discardBindings)
        {
            if (discardBindings)
            {
                //Discard Bindings for Variables introduced in this Graph Pattern
                foreach (String var in this._tempVariables)
                {
                    if (this._bindings.ContainsKey(var))
                    {
                        this._bindings[var].Clear();
                    }
                }
            }
            if (!parentOptional)
            {
                this._tempVariables.Clear();
            }
        }

        /// <summary>
        /// Filters binds created by a Triple Pattern execution to discard previous Binds that are invalidated by the latest Binds
        /// </summary>
        /// <param name="pattern"></param>
        /// <remarks>
        /// The purpose of this function is to Filter previous Bindings.  If this Pattern uses a Variable that already has stuff bound to it 
        /// from a previous Pattern execution then it is necessary to ensure that the Values produced by those Bindings are limited to the
        /// Values produced by these Bindings.
        /// </remarks>
        protected internal void FilterBinds(ITriplePattern pattern)
        {
            //No need to do this if this is the 1st Pattern we've executed
            if (this._currTriplePatternID == 0) return;

            //Find the Variables used (if any)
            String subj, pred, obj;
            List<String> existingVars = new List<string>();
            List<String> newVars = new List<string>();

            this._disjoint = false;

            if (pattern is TriplePattern)
            {
                TriplePattern p = (TriplePattern)pattern;
                if (p.Subject is VariablePattern)
                {
                    subj = ((VariablePattern)p.Subject).VariableName;

                    if (this.HasVariableBindings(subj))
                    {
                        //List<INode> temp = (from b in this._bindings[s]
                        //                    where b.PatternID == this._currPatternID && b.TriplePatternID == this._currTriplePatternID
                        //                    select b.Node).ToList();
                        //this._bindings[s].RemoveAll(b => (b.PatternID == this._currPatternID && b.TriplePatternID < this._currTriplePatternID && !temp.Contains(b.Node)));
                        existingVars.Add(subj);
                    }
                    else
                    {
                        newVars.Add(subj);
                    }
                }
                if (p.Predicate is VariablePattern)
                {
                    pred = ((VariablePattern)p.Predicate).VariableName;

                    if (this.HasVariableBindings(pred))
                    {
                        //List<INode> temp = (from b in this._bindings[p]
                        //                    where b.PatternID == this._currPatternID && b.TriplePatternID == this._currTriplePatternID
                        //                    select b.Node).ToList();
                        //this._bindings[p].RemoveAll(b => (b.PatternID == this._currPatternID && b.TriplePatternID < this._currTriplePatternID && !temp.Contains(b.Node)));
                        existingVars.Add(pred);
                    }
                    else
                    {
                        newVars.Add(pred);
                    }
                }
                if (p.Object is VariablePattern)
                {
                    obj = ((VariablePattern)p.Object).VariableName;

                    if (this.HasVariableBindings(obj))
                    {
                        //List<INode> temp = (from b in this._bindings[o]
                        //                    where b.PatternID == this._currPatternID && b.TriplePatternID == this._currTriplePatternID
                        //                    select b.Node).ToList();
                        //this._bindings[o].RemoveAll(b => (b.TriplePatternID < this._currTriplePatternID && !temp.Contains(b.Node)));
                        existingVars.Add(obj);
                    }
                    else
                    {
                        newVars.Add(obj);
                    }
                }
            }
            else if (pattern is SubQueryPattern)
            {
                foreach (String var in pattern.Variables)
                {
                    if (this.HasVariableBindings(var))
                    {
                        existingVars.Add(var);
                    }
                    else
                    {
                        newVars.Add(var);
                    }
                }
            }

            //Do the Filtering of Previous Bindings
            foreach (String var in existingVars)
            {
                List<INode> temp = (from b in this._bindings[var]
                                    where b.PatternID == this._currPatternID && b.TriplePatternID == this._currTriplePatternID
                                    select b.Node).ToList();
                this._bindings[var].RemoveAll(b => (b.TriplePatternID < this._currTriplePatternID && !temp.Contains(b.Node)));
            }

            this.CheckTimeout();


            //Combine Bindings as appropriate
            if (existingVars.Count >= 1)
            {
                String oldVar = existingVars[0];
                List<int> removableBindings = new List<int>();

                //Get Bindings we've made to the Existing Variable in this Pattern execution
                List<Binding> newBindings = (from b in this._bindings[oldVar]
                                    where b.PatternID == this._currPatternID && b.TriplePatternID == this._currTriplePatternID
                                    select b).ToList();

                foreach (Binding b in newBindings)
                {
                    //Find all the previous Bindings to this Node for the Existing Variable
                    List<int> prevBindings = (from b1 in this._bindings[oldVar]
                                                     where b1.TriplePatternID < this._currTriplePatternID && b1.Node.Equals(b.Node)
                                                     select b1.BindingID).ToList();

                    removableBindings.Add(b.BindingID);

                    //Pair the new Bindings with the Existing Bindings
                    foreach (int j in prevBindings)
                    {
                        this.PairBindings(b.BindingID, j);
                        removableBindings.Add(j);
                    }
                }

                foreach (int i in removableBindings)
                {
                    this.Unbind(i);
                    this._tempBindingIDs.Remove(i);
                }
            }
            else
            {
                //If we only get new variables then the EndBindTransaction() function will combine stuff by
                //doing a cartesian product of all solutions since only new variables mean disjoint patterns
                this._disjoint = true;
            }
        }

        /// <summary>
        /// Pairs two Bindings into one Binding
        /// </summary>
        /// <param name="i">First Binding</param>
        /// <param name="j">Second Binding</param>
        protected internal void PairBindings(int i, int j)
        {
            //Get a new Binding ID
            this._maxBindingID++;
            int id = this._maxBindingID;

            //Get the relevant Bindings
            foreach (String varname in this._bindings.Keys) {
                List<Binding> bs = (from b in this._bindings[varname]
                                           where b.BindingID == i || b.BindingID == j
                                           select b).ToList();

                //Create new Bindings for all of these
                if (bs.Count == 2 && bs[0].Node.Equals(bs[1].Node))
                {
                    this._bindings[varname].Add(new Binding(bs[0].Node, id, this._currTriplePatternID, this._currPatternID));
                }
                else
                {
                    foreach (Binding b in bs)
                    {
                        this._bindings[varname].Add(new Binding(b.Node, id, this._currTriplePatternID, this._currPatternID));
                    }
                }
            }

            this._tempBindingIDs.Add(id);                                             
        }

        /// <summary>
        /// Binds a Projected Value to a Variable
        /// </summary>
        /// <param name="var">Variable</param>
        /// <param name="value">Projected Value</param>
        /// <param name="bindingID">Binding ID</param>
        protected internal void BindProjection(String var, INode value, int bindingID)
        {
            if (!this._bindings.ContainsKey(var))
            {
                this._bindings.Add(var, new List<Binding>());
            }
            this._bindings[var].Add(new Binding(value, bindingID, -1, -1));
        }

        /// <summary>
        /// Creates an single empty Binding of null to each variable
        /// </summary>
        /// <param name="vars"></param>
        protected internal void BindEmpty(IEnumerable<SparqlVariable> vars)
        {
            if (this._validBindingsIDs.Count > 0)
            {
                throw new RDFQueryException("Can't create an Empty Binding when values have already been bound to variables");
            }
            else
            {
                foreach (SparqlVariable v in vars)
                {
                    if (!this._bindings.ContainsKey(v.Name))
                    {
                        this._bindings.Add(v.Name, new List<Binding>());
                        this._bindings[v.Name].Add(new Binding(null, 0, 0, 0));
                    }
                }
                this._validBindingsIDs.Add(0);
            }
        }

        /// <summary>
        /// Binding method for Optimising SELECT * {?s ?p ?o} type queries
        /// </summary>
        /// <param name="vars">Variables being bound to</param>
        /// <param name="p">Triple Pattern</param>
        /// <param name="store">Store being queried over</param>
        protected internal void BindAll(IEnumerable<SparqlVariable> vars, TriplePattern p, IInMemoryQueryableStore store) 
        {
            if (this._validBindingsIDs.Count > 0)
            {
                throw new RDFQueryException("Can't create a complete Binding when values have already been bound to variables");
            }
            else
            {
                foreach (SparqlVariable v in vars)
                {
                    if (!this._bindings.ContainsKey(v.Name))
                    {
                        this._bindings.Add(v.Name, new List<Binding>());
                    }
                }

                this.StartBindTransaction(p);
                int i = 0;
                foreach (Triple t in store.QueryTriples)
                {
                    this.Bind(t, p);
                    i++;
                    if (i == 1000)
                    {
                        this.CheckTimeout();
                        i = 0;
                    }
                }
                this.EndBindTransaction();

                i = 0;
                foreach (int id in this._tempBindingIDs)
                {
                    this._validBindingsIDs.Add(id);
                    i++;
                    if (i == 1000)
                    {
                        this.CheckTimeout();
                        i = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Binding method for binding the results of LET assignments into a Query
        /// </summary>
        /// <param name="var">Variable being bound to</param>
        /// <param name="value">Value to bind</param>
        /// <param name="bindingID">Binding ID</param>
        protected internal void BindAssignment(String var, INode value, int bindingID)
        {
            //Get a new Binding ID if needed
            if (bindingID == -1)
            {
                bindingID = this.GetBindingID(var, String.Empty, String.Empty);
                this._tempBindingIDs.Add(bindingID);
            }

            //Add the Binding
            if (!this._bindings.ContainsKey(var)) this._bindings.Add(var, new List<Binding>());
            this._bindings[var].Add(new Binding(value, bindingID, this._currTriplePatternID, this._currPatternID));
        }

        /// <summary>
        /// Removes an invalid Binding
        /// </summary>
        /// <param name="id">Binding ID</param>
        protected internal void Unbind(int id)
        {
            foreach (String varname in this._bindings.Keys)
            {
                this._bindings[varname].RemoveAll(b => b.BindingID == id);
            }
            this._validBindingsIDs.Remove(id);
            this._tempBindingIDs.Remove(id);
        }

        /// <summary>
        /// Removes a partial invalid Binding (used for filtering Optional Graph Pattern bindings)
        /// </summary>
        /// <param name="id">Binding ID</param>
        protected internal void PartialUnbind(int id)
        {
            foreach (String varname in this._tempVariables)
            {
                this._bindings[varname].RemoveAll(b => b.BindingID == id);
            }
        }

        /// <summary>
        /// Internal Helper function which checks whether the Execution Timeout has been execeeded
        /// </summary>
        private void CheckTimeout()
        {
            if (this._executionTimeout > 0)
            {
                if (this._executionTimer.ElapsedMilliseconds > this._executionTimeout)
                {
                    this._executionTimer.Stop();
                    throw new RDFQueryTimeoutException("Query Execution Time exceeded the Timeout of " + this._executionTimeout + "ms, query aborted after " + this._executionTimer.ElapsedMilliseconds + "ms");
                }
            }
        }

        #endregion

        /// <summary>
        /// Sorts the Solutions using the given Ordering
        /// </summary>
        /// <param name="orderBy">An Ordering on Solutions</param>
        public void Sort(ISparqlOrderBy orderBy)
        {
            if (orderBy != null)
            {
                //Set Binding Context
                orderBy.BindingContext = this;

                //Sort the Binding Solutions
                this._solutions.Sort(orderBy);
            }
        }

        /// <summary>
        /// Applies Limit and Offset to the Solutions
        /// </summary>
        /// <param name="limit">Solution Limit</param>
        /// <param name="offset">Solution Offset</param>
        protected internal void Slice(int limit, int offset)
        {
            //Apply Offset - If the Offset is greater than the number of results nothing is returned
            this._solutions.RemoveRange(0, Math.Min(offset, this._solutions.Count));

            //Apply Limit
            if (limit >= 0)
            {
                if (this._solutions.Count > limit)
                {
                    this._solutions.RemoveRange(limit, this._solutions.Count - limit);
                }
            }
        }

        /// <summary>
        /// Disposes of a Result Binder
        /// </summary>
        public void Dispose()
        {
            //Clear ID lists
            this._tempBindingIDs.Clear();
            this._validBindingsIDs.Clear();
            this._triplePatternIDs.Clear();
            //Clear Transactions
            this._transactions.Clear();
            //Clear Bindings and Solutions
            this._bindings.Clear();
            this._solutions.Clear();
        }
    }
}
